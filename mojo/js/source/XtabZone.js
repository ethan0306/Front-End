(function(){

    mstrmojo.requiresCls(
            "mstrmojo.GridBase",
            "mstrmojo.Grid");

    /**
     * <p> XtabZone Widget is responsible for displaying a zone in the MicroStrategy Xtab (e.g. Titles, Row Headers, Col Headers, Metric Values) . <p>
     *
     *  <p> An Xtab rendered through mstrmojo.Xtab is essentially a container with four separate zones (TopLeft, TopRight, BottomLeft, BottomRight).
     *  These zones are essentially Grids (HTML Tables). Based on the lock header setting,  a zone would render either Titles, Column Headers, Row Headers or Metric Values
     *  OR a combination of those e.g. for Both lock headers ON, TopLeft zone renders Xtab Titles as a grid, TopRight zone renders ColHeaders, BottomLeft renders RowHeaders and BottomRight renders Metric Values.
     *  For Lock Row Headers only, BottomLeft zone renders Xtab Titles + Row Headers as a grid, BottomRight zone renders ColHeaders + Metric Values while the top zones are rendered empty.
     *
     *  @class
     *  @extends mstrmojo.OndemandGrid
     */
    mstrmojo.XtabZone = mstrmojo.declare(
        // superclass
        mstrmojo.Grid,

        // mixins
        null,

        /**
         * @lends    mstrmojo.XtabZone
         */
        {
            /**
             * Script Class
             * @type String
             */
            scriptClass: "mstrmojo.XtabZone",

            /**
             * Markup
             * @type String
             */
            markupString: '<div id="{@id}" class="mstrmojo-XtabZone" style="position:relative;{@cssText}"></div>',

            /**
             * Markup Slots. We define the container node for the Grid here.
             * @type String
             */
            markupSlots: {
                gridContainerNode: function(){ return this.domNode; }
            }
        }   // close - instance methods block.
    );

}());

(function(){

    /**
     * <p> XtabCP represents the base Content Provider for an XtabZone. </p>
     *
     * <p> The role of Xtab Content Provider is to act as an adaptor between XtabZone and Grid Data. So, the presentation layer (XtabZone) doesn't need to know the internals of Grid JSON Data. It simply
     * works off a simple content provider interface that essentially answers queries like how many rows does the grid has, how many columns, their widths, cells for a given row. </p>
     *
     * <p> Having an adapter like XtabCP helps particularly for Xtab rendering as the original Grid Data (JSON packet generated by the transform) makes heavy use of lookup mechanisms to keep
     * the JSON size compact (e.g. element definitions are shared and headers use lookup indices to avoid duplicating the data). So XtabZone doesn't need to worry about
     * things like how to resolve the header names, tracing parent headers (used for sorting, hyperlinks), managing interactivity related hooks. </p>
     *
     *  @class
     */
    mstrmojo.XtabCP = mstrmojo.declare(
        null,

        // mixins
        null,

        /**
         * lends mstrmojo.XtabCP
         */
        {
            /**
             * Script Class
             * @type String
             */
            scriptClass: "mstrmojo.XtabCP",

            /**
             * Base Node in the Grid JSON Data from where to retrieve the contents for this content provider. e.g. If this content provider needs to represent row headers,
             * this variable needs to be refer to the ghs.rhs node in the Grid JSON.
             * @type JSON Node
             */
            base:null,

            /**
             * <p> Base Lookup Node in the Grid JSON Data from where to retrieve the element definitions. </p>
             *
             * <p> To keep Grid JSON compact we don't include element definitions within the header nodes. Instead they have lookup indices. This configuration property
             * helps Content Provider to resolve the lookup indices as it points it to the subtree (e.g. gts.row) where it find the definitions </p>
             *
             * <p> This field would be used only for headers. </p>
             * @type JSON Node
             */
            lookupBase:null,

            /**
             * Column widths for the (grid) zone represented by this Content Provider. This property is used by XtabZone to render the HTML table widths.
             * @type Array
             */
            colWidths:null,

            /**
             * When set to true, this property implies that rows corresponding to this content provider should ignore fixed height.
             * @type Boolean
             */
            forceAutoRowHeight:false,

            /**
             * Since Content Providers (CP) can be aggregated, each CP typically represents a block of rows within the XTab. For purposes like stitching this internal counter is used to know
             * the starting position (row index) that this Content Provider represents.
             * @type Integer
             */
            startIndexInContainer:0,

            /**
             * An object records the rows that contains change
             * @type Object
             */
            updatedRows: null,

            /**
             * When the new data structure is completely unmatched (e.g. cell row spans are different), we need to preserve the updated rows
             * @type Boolean
             */
            preServeUpdatedRows: true,

            /**
             *
             * @constructs
             * @param {Object} props A hash of property names/values. Typically this Content Provider expects the following properties
             * <ul>
             * <li>gridData:Grid JSON</li>
             * <li>type:Integer enum representing the content provider type</li>
             * <li>base:Grid JSON Node that serves as the base node for the content provider</li>
             * <li>interactiveCellsArray:Array where the Content Provider will add cells that it realizes are interactive. See mstrmojo.Xtab#interactiveCellsArray for more details</li>
             * </ul>
             */
            init:function init(/* JSON */ props) {
                mstrmojo.hash.copy(props, this);
            },

            /**
             * Initializes the content information e.g. row count, column widths and caches them as instance properties.
             * This method should be called before we start rendering a grid.
             * @param {Integer} startIndexInContainer An optional parameter that indicates the index of the first row represented by this Content Provider. This property is only used internally
             * when Content Providers are aggregated.
             * @refactoring can we move some/all of this logic to init.
            */
            initContent: function initContent(/* Integer */ startIndexInContainer) {
                this.startIndexInContainer = startIndexInContainer || this.startIndexInContainer || 0;
                var s = this.base.show,
                items = this.base.items;
                this.rc =  s && items ? items.length : 0;
                this.colWidths = s && this.base.cws || [];
                this.isDownloading = false;
                this.invalidData = false;
            },

            /**
             * Indicates whether Grid Rows specified are available or need to be downloaded from IServer.
             * @param {Integer} startRow Start Row.
             * @param {Integer} endRow End Row.
             * @returns (Boolean) whether grid rows specified are available or need to be downloaded.
            */
            isDataAvailable:function isDataAvailable(/* Integer */ startRow, /* Integer */ endRow) {
                return !this.invalidData;
            },

            /**
             * Triggers downloading of specified Grid Rows from IServer. Note that this is an asynchronous call so that the rendering widget is not blocked. When we have downloaded
             * the corresponding block of data from IServer, Xtab would ensure that it notifies the necessary zones (XtabZone).
             * @param {Integer} startRow Start Row.
             * @param {Integer} endRow End Row.
            */
            download:function download(/* Integer */ startRow, /* Integer */ endRow) {
                if(!this.isDownloaded && !this.isDownloading && this.dataSource) {
                    this.isDownloading = true;
                    this.dataSource.download(0);
                }
            },

            invalid:function invalid() {
                this.invalidData = true;
                this.preServeUpdatedRows = true;
                if(this.gridData) {
                    this.oldGridData = this.gridData;
                    this.oldBase = this.base;
                    this.updatedRows = {};
                }
            },

            /**
             * Get the row height for a given type. Should be subclassed.
             */
            getRowHeight: function getRowHeight() {
                return this.gridData.rh;
            },
            
            /**
             * Returns the number of initial rows that need to be rendered in Auto mode. This is bit of a hackish solution to support the case that Titles/ColHeaders in XTab are rendered as auto height.
             * They don't use fixed height. So, the idea is that xtabzone can ask the provider and figure, if any of the initial rows need to be rendered in auto height. This way xtabzone still doesn't need
             * to know specifics about Xtab (titles, col headers etc.). It continues to work off a generic content provider paradigm. Still more ideal solution would be to have a more generic API like getRowHeightConfig
             * that returns a JSON representing a map of rowheights and rowBlocks. For simplicity sake we limit the solution to this API for now. Eventually we should evaluate the generic API
             */
            getNumAutoHeightRows: function () {
                return this.forceAutoRowHeight ? this.rc : 0;
            },

            /**
             * Returns the number of rows that are available/downloaded.
             * @return {Integer} number of rows that are downloaded.
             */
            getAvailableRowsCount: function getAvailableRowsCount() {
                return this.rc;
            },

            getUpdatedRows: function getUpdatedRows() {
                return this.updatedRows;
            },

            /**
             * Returns cells for a given row.
             * @param {Integer} ri Row Index
             * @returns {Array} Grid JSON Cell objects that include the following properties used by the XtabZone
             * <ul>
             * <li>rs:Row Span</li>
             * <li>cs:Column Span</li>
             * <li>v:Value
             * <li>css:Css class names</li>
             * <li>_ei:Extra Info. This property value is rendered in the HTML generated for the <td> as "ei" attribute. This is effetively a means for ContentProviders to ask widget to render information that features like
             *  interactivity would need.</li>
             * </ul>
             */
            getRowCells: function (/*Integer*/ ri) {
                var bi = this.base.items,
                    r = bi[ri],             // row.
                    cells = r.items,
                    lb = this.lookupBase,
                    ics = this.interactiveCellsArray,
                    cssBase = this.gridData.css,
                    e = null,
                    totalSet = false,
                    oldGd, oldBase, oldItems, oldCells;

                if(this.oldGridData) {
                    oldGd = this.oldGridData;
                    oldBase = this.oldBase;
                    oldItems = oldBase && oldBase.items;
                    oldCells = oldItems[ri] && oldItems[ri].items;
                }

                for (var ci=0, len=cells && cells.length || 0; ci<len; ci++) {
                    var cell = cells[ci];
                    if (cell) {
                        cell.v = cell.v || cell.n;
                        if (lb && !cell._e) {
                            var unit = lb[cell.tui];
                            e = unit && unit.es[cell.idx];
                            if (e) {
                                cell.v = cell.v || e.n; //we need to first check cell.v because the cell's v value has higher priority than the name of the look up element
                                if(e.rv) {
                                    cell.rv = e.rv;
                                }
                                // if we found the element object for the cell, attach it to the cell too. This will be useful during actions (looking up element ID) - especially for cases where there are multiple grid data blocks.
                                cell._e = e;
                            }
                        }
                        if(!cell.css) {
                            cell.css = cssBase[cell.cni].n;
                        }

                        //Transactions: check whether there is any data in the row gets changed
                        if(!cell._d && oldCells && this.preServeUpdatedRows) {
                            var oldCell = oldCells[ci];
                            if(!oldCell || (oldCell.rs !== cell.rs)) {
                                this.preServeUpdatedRows = false;
                                this.updatedRows = {};
                            } else if((oldCell.v && cell.v !== oldCell.v)) {
                                data = {};
                                if(cell.v !== oldCell.v) {
                                    data.v = oldCell.v;
                                }
                                if(cell.css !== oldCell.css) {
                                    data.css = oldCell.css;
                                }
                                cell._d = data;
                                //save the row number into the updatedRows object
                                this.updatedRows[this.startIndexInContainer + ri] = true;
                            }
                        }

                        // Debug Info....
                        //cell._di = (this.blockNum || 0) + "_" + ri + "_" +ci;

                        //TQMS 465449 465725, need to remember the reference to the grid data to find the proper title
                        cell._gd = this.gridData;

                        // is the cell interactive ? do we have an interactiveCellsArray setup (by xtab) ?
                        if(cell.at > 0 && ics) {
                            // add the cell to the interactive cells cache. Get the lookup index and add it to the cell as extraInfo (this attribute will be picked up by the table renderer during onclick).Avoid adding twice (due to stitching).
                            if(cell._ei === undefined) {
                                cell._ei = ics.push(cell) - 1;
                            }

                        }
                        // store the axis information. This can come in the JSON also, but, this should be more efficient. than repeating the information in JSON several times.
                        if(this.axis) {
                            cell.axis = this.axis;
                        }

                        // also update the parent reference.
                        var parentIndices = cell.pi;
                        if(parentIndices) {
                            // for headers, the parent indices would be passed directly (rowIndex, cellIndex)
                            if(parentIndices.ri !== undefined && parentIndices.ci !== undefined) {
                                // parent reference. Go to the items of the previous row and look for cell with index -> pi.
                                cell._p = bi[parentIndices.ri].items[parentIndices.ci];
                            } else {
                                // metric values. Left and Top indices.
                                var ghs = this.gridData.ghs,
                                        leftPi = parentIndices.left,
                                        topPi = parentIndices.top;

                                // if left parent indices are present, update the left parent reference on the cell.
                                if(leftPi) {
                                    cell._lp = ghs.rhs.items[leftPi.ri].items[leftPi.ci];
                                }

                             // and if top parent indices are present, update the that parent reference on the cell.
                                if(topPi) {
                                    cell._tp = ghs.chs.items[topPi.ri].items[topPi.ci];
                                }
                            }
                        }

                    }
                }

                return cells;
            },

            /**
             * Gets the missing cells for the give row.  In merged header case, the cells are merged across rows.
             * For a given row, the first data item might not be the first cell displayed in the row. This function
             * will find the missing cells at the beginning of the given row that are missing.
             * @returns {Array} The array of the "missing" cell object. The new row span of the "missing" cell should
             * be its (parent's) original row span minus the offset of the current row to its parent.
             */
            getUnmergedCells: function getUnmergedCells(/*Integer*/ri) {
                var ac = [],
                    rows = this.base.items,
                    cssBase = this.gridData.css,
                    cell = rows[ri].items[0], // start inspecting the first cell
                    pi = cell && cell.pi, // get the parent index node
                    r = pi && pi.ri, // row number for the parent node
                    c = pi && pi.ci; // column number for the parent node

                while(pi && r > -1 && c > -1) {
                    // get the parent of selected cell
                    cell = cell._p || rows[r].items[c];
                    var _c = {};
                    // make a copy of the parent
                    mstrmojo.hash.copy(cell, _c);
                    if(!_c.css) {
                        _c.css = cssBase[_c.cni].n;
                    }
                    // adjust its row span as it the cell start from the current row
                    _c.rs = cell.rs - ri + r; //cell.rs - (ri - r)
                    // put it to the top of the array
                    ac.splice(0, 0, _c);
                    // find the next parent
                    pi = cell && cell.pi;
                    r = pi && pi.ri;
                    c = pi && pi.ci;
                }

                return ac;
            }
        }
    );
})();

(function(){
    /**
     * <p>XtabVACP represents a vertical aggregation of content providers.</p>
     *
     * <p> It essentially aggregates the rows of a number of Content Providers. As a result rows from different Content Providers
     * end up being rendered within a single XtabZone (HTML) table </p>
     *
     * <p> While basic content providers represent single zones (e.g. titles, headers), aggregated Content Provider can aggregate zones of a xtab e.g. for .
     * for lock row headers (only) case it would help aggregate the titles & rowHeaders Content providers. So, titles and row headers rows end up rendering in a single table (XtabZone) as against
     * lock header BOTH case where they need to be rendered in separate tables</p>
     *
     *  @class
     *  @extends mstrmojo.XtabCP
     */
    mstrmojo.XtabVACP = mstrmojo.declare(
        // superclass
        mstrmojo.XtabCP,

        // mixins
        null,

        /**
         * @lends mstrmojo.XtabVACP
         */
        {
            scriptClass: "mstrmojo.XtabVACP",

            /**
             * Represents the Content Providers that this object aggregates.
             * @type Array
             */
            cps:[],

            initContent: function initContent(/* Integer */ startIndexInContainer) {
                this.startIndexInContainer = startIndexInContainer || 0;
                this.rc = 0;
                this.type = 0;
                this.colWidths = [];
                for(var i=0;i<this.cps.length;++i) {
                    var cp = this.cps[i];
                    // pass on to the CP its starting index within the container.
                    cp.initContent(this.startIndexInContainer + this.rc);
                    this.rc += cp.rc;
                    this.type |= cp.type;
                    var cws = cp.colWidths;
                    // we can't really rely on any one CPs colWidths - since there may be some that don't really have any (e.g. hidden titles, OnDemand CPs). So, we just pick the one that has max col widths set.
                    if(cws && (cws.length > this.colWidths.length)) {
                        this.colWidths = cws;
                    }
                }
            },

            getNumAutoHeightRows: function () {
                // The API is used to to provide the initial rows that need to be set to Auto (e.g. Titles, colheaders zone). We are doing small cheat here - since none of our Vert/Horiz Content providers
                // would need to force Auto Row Height for 2nd content provider (it would be rowHeaders, values or H ACP(rowHeaders, values) which always honor the fixed row height), we just query
                // the top content provider.
                return this.cps[0].getNumAutoHeightRows();
            },

            /**
             * Get the row height for a given type.
             */
            getRowHeight: function getRowHeight() {
                return this.cps[0].getRowHeight();
            },            
            
            /**
             * Returns cells for a given row.
             */
            getRowCells: function (/*Integer*/ ri) {
                var i = 0,
                cp = this.cps[i];

                // we need to find the content provider corresponding to the row index passed.
                while(ri >= cp.rc) {
                    // go to the next content provider and update the row index.
                    ri -= cp.rc;
                    cp = this.cps[++i];
                }
                return cp.getRowCells(ri);
            },

            // todo: should we refactor the code since it has duplicated code to find the proper cp.
            // but if we do that, the number of function calls will get increased.
            getUnmergedCells: function(ri) {
                var i = 0,
                cp = this.cps[i];

                while(ri >= cp.rc) {
                    ri -= cp.rc;
                    cp = this.cps[++i];
                }

                return cp.getUnmergedCells(ri);
            },

            isDataAvailable:function isDataAvailable(/* Integer */ startIndex, /* Integer */ endIndex) {
                var targetCPs = this._getCPs(startIndex, endIndex);

                for(var i=0;i<targetCPs.length;++i) {
                    if(!targetCPs[i].isDataAvailable(startIndex, endIndex)) {
                        return false;
                    }
                }

                return true;
            },

            getAvailableRowsCount: function getAvailableRowsCount() {
                var rowDownloaded = 0;

                for(var i=0;i<this.cps.length;++i) {
                    var cp = this.cps[i];
                    if(cp.isDataAvailable()) {
                        rowDownloaded += cp.getAvailableRowsCount();
                    }
                }

                return rowDownloaded;
            },

            _getCPs: function getCPs(/* Integer */ startIndex, /* Integer */ endIndex) {
                var i = 0,
                cp = this.cps[i],
                si = cp && cp.startIndexInContainer,
                targetCPs = [];

                // reset the offse of the start and end index
                if(cp) {
                    startIndex -= si;
                    endIndex -= si;
                }

                // what CP corresponds to the start ?
                while(cp && startIndex >= cp.rc) {
                    // since our index is past the current CP, we will update the index.
                    startIndex -= cp.rc;
                    endIndex -= cp.rc;

                    // go to the next content provider.
                    cp = this.cps[++i];
                }

                // now keep adding CPs till we reach the end index.
                while(cp && endIndex >= cp.rc) {
                    endIndex -= cp.rc;
                    targetCPs.push(cp);
                    // go to the next content provider.
                    cp = this.cps[++i];
                }

                // add the last CP.
                if(cp) {
                    targetCPs.push(cp);
                }

                return targetCPs;
            },

            invalid: function invalid() {
                for(var i=0;i<this.cps.length;++i) {
                    var tcp = this.cps[i];
                    tcp.invalid();
                }
                this.updatedRows = {};
            },

            getUpdatedRows: function getUpdatedRows() {
                var v = {};
                for(var i=0;i<this.cps.length;++i) {
                    var tcp = this.cps[i];
                    if(!tcp.preServeUpdatedRows) {
                        return {};
                    } else {
                        mstrmojo.hash.copy(tcp.getUpdatedRows(), v);
                    }
                }
                this.updatedRows = v;
                return v;
            },

            download: function download(/* Integer */ startIndex, /* Integer */ endIndex) {
                var targetCPs = this._getCPs(startIndex, endIndex);

                for(var i=0;i<targetCPs.length;++i) {
                    var tcp = targetCPs[i];
                    tcp.download(startIndex, endIndex);
                }
            }
        }
    );
})();

(function(){
    /**
     * <p>XtabHACP represents a horizontal aggregation of content providers.</p>
     *
     * <p> It essentially aggregates the columns of a number of Content Providers. As a result columns from different Content Providers
     * end up being rendered within a single XtabZone (HTML) table </p>
     *
     * <p> While basic content providers represent single zones (e.g. titles, headers), aggregated Content Provider can aggregate zones of a xtab e.g. for .
     * for lock col headers (only) case it would help aggregate the titles & colHeaders Content providers. So, titles and col headers end up rendering as a single table (XtabZone) as against
     * lock header BOTH case where they need to be rendered in separate tables</p>
     *
     *  @class
     *  @extends mstrmojo.XtabCP
     */
    mstrmojo.XtabHACP = mstrmojo.declare(
        // superclass
        mstrmojo.XtabCP,

        // mixins
        null,

        /**
         * @lends mstrmojo.XtabHACP
         */
        {
            scriptClass: "mstrmojo.XtabHACP",

            /**
             * Represents the Content Providers that this object aggregates.
             * @type Array
             */
            cps:[],

            initContent: function initContent(/* Integer */ startIndexInContainer) {
                this.startIndexInContainer = startIndexInContainer || 0;
                this.type = 0;
                this.colWidths = [];

                for(var i=0;i<this.cps.length;++i) {
                    this.cps[i].initContent(this.startIndexInContainer);
                    this.type |= this.cps[i].type;

                    var cw = this.cps[i].colWidths;

                    // col widths for HACP is a concatenation of individual CPs. However, we may have ONDemand CPs that
                    // won't have a col width (TQMS:39040) and we don't want to account those.
                    if(cw) {
                        this.colWidths = this.colWidths.concat(cw);
                    }
                }

                this.rc = Math.max(this.cps[0].rc, this.cps[1].rc);

                // col widths should be the same for both providers as they are vertically stacked.
                //this.colWidths = [].concat(this.cps[0].colWidths).concat(this.cps[1].colWidths);
            },

            getNumAutoHeightRows: function () {
                return Math.max(this.cps[0].getNumAutoHeightRows(), this.cps[1].getNumAutoHeightRows());
            },

            getRowCells: function (/*Integer*/ ri) {
                var cps = this.cps,
                    cells = [];
                for (var i=0,len=cps.length; i<len; i++) {
                    // TQMS 429142, 466955 if the aggregator's rc has no data in the rows, that means the cp do not contain the rows we are expecting
                    // This happens when the row headers are set to be hidden
                    if (cps[i].getAvailableRowsCount() > 0 && cps[i].rc > ri) {
                        var tmp = cps[i].getRowCells(ri);
                        if (tmp) {
                            cells = cells.concat(tmp);
                        }
                    }
                }
                return cells;
            },

            /**
             * Get the row height for a given type.
             */
            getRowHeight: function getRowHeight() {
                return this.cps[0].getRowHeight();
            },            
            
            getUnmergedCells: function(/*Integer*/ri) {
                return this.cps[0].getUnmergedCells(ri);
            },

            isDataAvailable:function isDataAvailable(/* Integer */ startIndex, /* Integer */ endIndex) {
                // we assume incremental fetch only on rows. So, we can just check the first content provider here. Its not possible to have row headers ready and not metrics (or vice versa).
                return this.cps[1].isDataAvailable(startIndex, endIndex);
            },

            getAvailableRowsCount: function getAvailableRowsCount() {
                return Math.max(this.cps[0].getAvailableRowsCount(), this.cps[1].getAvailableRowsCount());
            },

            invalid: function invalid() {
                var i, len, cp;
                for(i=0,len=this.cps.length; i<len; ++i) {
                    cp = this.cps[i];
                    cp.invalid();
                }
                this.updatedRows = {};
            },

            getUpdatedRows: function getUpdatedRows() {
                var v = {};
                for(var i=0;i<this.cps.length;++i) {
                    var tcp = this.cps[i];
                    if(!tcp.preServeUpdatedRows) {
                        return {};
                    } else {
                        mstrmojo.hash.copy(tcp.getUpdatedRows(), v);
                    }
                }
                this.updatedRows = v;
                return v;
            },

            download: function download(/* Integer */ startIndex, /* Integer */ endIndex) {
                var cp = this.cps[1];
                cp.download(startIndex, endIndex);
            }
        }
    );
})();

(function(){

    /**
     * <p>XtabTitles acts as the content provider for the titles zone of a Xtab. </p>
     *
     *  <p>While we can have generic content providers for Row Headers, Col Headers and Metric Value zones, we need a dedicated one for Titles Zone since the
     *  grid JSON for Titles Zone doesn't come in an exact tabular format that we can pass on to XtabZone as XtabCP does. For Titles, Grid JSON essentially represents
     *  the template structure (e.g. what titles below to a given axis) and properties like whether titles need to be shown, whether we want to remove the extra column.
     *  XtabTitlesCP pre processes this information and finally by conforming to the XtabCP interface it makes sure that the Titles information in Grid JSON is abstracted from the
     *  XtabZone </p>
     *
     *  @class
     *  @extends mstrmojo.XtabCP
     */
    mstrmojo.XtabTitlesCP = mstrmojo.declare(
        // superclass
        mstrmojo.XtabCP,

        // mixins
        null,

        /**
         * @lends mstrmojo.XtabTitlesCP
         */
        {
            scriptClass: "mstrmojo.XtabTitlesCP",

            init:function init(/* JSON */ props) {
                this._super(props);
            },

            download:function download(/* Integer */ startRow, /* Integer */ endRow) {
            },

            initContent: function initContent(/* Integer */ startIndexInContainer) {
                this.startIndexInContainer = 0;
                
                //Cache the original grid data that we get from the server.
                if (!this.cts) {
                    this.cts = mstrmojo.hash.clone(this.gridData.gts.col);
                }
                
                // adapt our base to the the titles tree in the grid data.
                var gts = this.gridData.gts,
                    isLockHeaders = (this.gridData.lhv !== 0),
                    rts = gts.row || [],
                    dataCts = gts.col || [],
                    s = gts.show,
                    rec = gts.rec,                  // remove extra column.
                    cts = this.cts || [],
                    nRts = rts.length,              // number of row titles.
                    nCts = cts.length,              // number of col titles.
                    cssBase = this.gridData.css;    // Css class name cache.

                this.base = {
                    items:[]
                };

                // number of rows for this zone would be the number of col titles.
                this.rc = s && cts.length || 0;

                if (this.rc === 0 && s) {
                    // case with no items on the col axis.
                    this.rc = nRts > 0 ? 1 : 0;
                }

                this.colWidths = s && gts.cws || [];

                // no row count. Just return;
                if(!this.rc) {
                    return;
                }

                // cache the row cells.
                var cells = {items:[]},
                    lrs = 1,
                    lastCell,               // Cache for the last cell title with a rowspan greater than 1.
                    i;

                // add all but last row titles.
                for(i = 0; i < nRts; ++i) {
                    rts[i].axis = 1;                    // we don't ship axis information in the JSON. todo - maybe for Titles, we should?
                    rts[i].ui = i;
                    cells.items.push(rts[i]);
                }

                // Add first col title.
                if (nCts > 0) {
                    cts[0].axis = 2;                    // we don't ship axis information in the JSON.
                    cts[0].ui = 0;
                    dataCts[0].axis = 2;               //apply the change on the data model
                    dataCts[0].ui = 0;
                    
                    lrs = cts[0].rs || 1;

                    // Are the headers locked and does this title have a rowspan greater than 1?
                    if (isLockHeaders && lrs > 1) {
                        // This will result in empty rows so use a rowspan of 1 instead, and...
                        cts[0].rs = 1;
                        
                        // create a dummy cell that will be inserted once for each extra row span value.
                        lastCell = mstrmojo.hash.clone(cts[0], {});

                        // reset the 'n' value of the dummy cell so no text will appear...
                        lastCell.n = '&nbsp;';
                        
                        // change the class for the original cell to include the first stitching rule.
                        cts[0].cni = cssBase.push({
                            n: (cssBase[cts[0].cni].n || '') + ' fsbp_1'
                        }) - 1;
                    }

                    cells.items.push(cts[0]);
                }

                var bi = this.base.items;
                bi.push(cells);

                // subsequent rows are just column titles. Note - loop starts at 1 since we have already added the first col in the first row.
                for(i = 1; i < nCts; ++i) {
                    // Did the last title have a rowspan greater than 1?
                    if (lrs > 1) {
                       // If headers are locked the cell for each row has to be cloned from the last title.
                       var cnt = lrs;

                       // Insert a row for each extra row span.
                        while(cnt-- > 1) {
                            // Are headers locked?
                            if (isLockHeaders) {
                                //Create a clone of the last cell.
                                var clone = mstrmojo.hash.clone(lastCell, {});

                                // Need to append css class names for stitching.
                                clone.cni = cssBase.push({
                                    n: (cssBase[clone.cni].n || '') + ' fsbp_' + ((cnt == 1) ? '3' :  '2')
                                }) - 1;
                                
                                //Push the clone cell into the base
                                bi.push({
                                    items: [ clone ]
                                });
                            } else {
                                //In the non-locked header case, push an empty array.
                                bi.push({items:[]});
                            }
                        }
                    }
                    
                    cts[i].axis = 2;
                    cts[i].ui = i;
                    dataCts[i].axis = 2;             //apply the change on the data model
                    dataCts[i].ui = i;
                    
                    lrs = cts[i].rs || 1;

                    // Are headers locked and does the current title have a rowspan?
                    if (isLockHeaders && lrs > 1) {
                        // This will result in empty rows so use a rowspan of 1 and cache the title for later use.
                        cts[i].rs = 1;
                        lastCell = mstrmojo.hash.clone(cts[i], {});
                        lastCell.n = '&nbsp;';
                        
                        // Append the top stitching css to the top most cell.
                        cts[i].cni = cssBase.push({
                            n: (cssBase[cts[i].cni].n || '') + ' fsbp_1'
                        }) - 1;
                    }

                    bi.push({items:[cts[i]]});
                }

                this.rc = bi.length;

                // handle removeExtraCol case.
                if(rec) {
                    this._removeExtraColumn(rts, cts);
                }
            },

            getAvailableRowsCount: function getAvailableRowsCount() {
                return this.rc;
            },

            isDataAvailable:function isDataAvailable(/* Integer */ startRow, /* Integer */ endRow) {
                return true;
            },

            /**
            * Converts base so that we don't have extra column any more.
            */
            _removeExtraColumn: function removeExtraColumn(rts, cts) {
                var nRts = rts && rts.length,
                         nCts = cts && cts.length,
                         gts = this.gridData.gts,
                         mRts = gts.row || [],
                         mCts = gts.col || [],
                         mnRts = mRts.length,
                         mnCts = mCts.length;

                // do we have both row and col titles ? If not, we don't need to remove any column.
                if(!nRts || !nCts) {
                    // we have a single col title.
                    if(nCts === 1) {
                        // in this case if Metrics is the only title, we should hide it. #395126

                        // last col title.
                        var lct = cts[nCts-1];

                        if(lct.otp == -1) {
                            // Flag the metrics to be hidden so that the individual metrics head will have the pivot button enabled
                            //TQMS 523817 set the hidden property to the grid data model instead of the cell clones in the base
                            if(mnCts > 0) {
                                mCts[mnCts-1]._hid = true;
                            }

                            // we have effectively no titles to show. So, clear the collection and update the row count.
                            this.base.items=[];
                            this.rc = 0;
                        }
                    }
                    return;
                }

                var lrt = rts[nRts-1], // get the last row title.
                    rc = this.rc, // cache the row count
                    bi = this.base.items; // cache base items

                // Within the base array, move this rowTitle so that it overrides the last col title. So, essentially we are removing the last colTitle.
                // todo1 - we should not override if the last rowTitle is Metrics.
                if(lrt) {
                    // If the last element is "Metrics", we should remove it from the base
                    if(lrt.otp == -1) {
                        // Flag the metrics to be hidden so that the individual metrics head will have the pivot button enabled
                        if(mnRts > 0) {
                            mRts[mnRts-1]._hid = true;
                        }
                        bi[0].items.splice(nRts-1, 1);
                    } else {
                        // First we update (override) the col title.

                        // Our colTitle to replace (last col title) would exist in the base [1] either as the last item in the 1st row, [2] or the last item in the last row depending on the number of col titles.
                        // find the row index index where our colTitle is.
                        var idx = rc > 1 ? rc -1 : 0,
                                r = bi[idx],
                                len = r.items.length;

                        // Flag the current last unit to be hidden;
                        if(len > 0 && mnCts > 0) {
                            mCts[mnCts-1]._hid = true;
                        }

                        // Data field 'fix' is the attribute form index, starting from 1
                        var afi = lrt.fix;
                        // Check whether the last row title is an attribute form
                        if(afi) {
                            // if the last cell is an attribute form, we should replace the colTitle with the attribute form row titles
                            for(var i = 0; i < afi; i++) {
                                r.items[len - 1 + i] = rts[nRts - afi + i];
                            }
                        } else {
                            // replace the colTitle with the last row title.
                            r.items[len-1] = lrt;
                        }

                        // If we remove the extra column, all the column title span on the top of
                        // the last column title should have the same column span, either the same as the last column title (it could be the merged title for multiple attribute forms)
                        // or the column span is the number of the last index of the attribute form (if the last column titles are attribute forms)
                        for(var j = 0, iLen = nCts -1; j < iLen; j++) {
                            cts[j].cs = afi ? afi : lrt.cs;
                        }

                        // now remove the last rowTitle.
                        // In our base array the last row title would figure in the first row, the number of row title to remove is either 1 or the number of attribute forms.
                        var rm = afi ? afi : 1;
                        bi[0].items.splice(nRts- rm, rm);
                    }
                }
                return;
            }
        }
    );
})();

(function(){
    /**
     * <p>XtabOnDemandCP represents content provider for each block of Grid data that needs to be downloaded incrementally from IServer as user scrolls to view them.
     * These Xtab rows weren't downloaded as part of the RWD JSON that was used to render this Xtab </p>
     *
     *  <p>XtabOnDemandCP is used for Incremental Fetch cases where we download and render Xtab data transparently ONLY as user scrolls them into the viewport. These content providers
     *  essentially represent 2 states. Initially they are dummy content providers that represent a row count corresponding to Incremental Fetch settings but no data rows (since they haven't been
     *  downloaded yet). However, once you trigger download on such providers they fetch the grid data asynchronously. Once data is downloaded
     *  they then initialize their content and act as a normal XtabCP</p>
     *
     *  @class
     *  @extends mstrmojo.XtabCP
     */    mstrmojo.XtabOnDemandCP = mstrmojo.declare(
            // todo2 - do we need this inheritance ?
            mstrmojo.XtabCP,

        // mixins
        null,

        /**
         * @lends XtabOnDemandCP
         */
        {
            scriptClass: "mstrmojo.XtabOnDemandCP",

            /**
             * Represents the block number. This value will be used during incremental fetch download.
             * @type Integer
             */
            blockNum:0,

            listeners: null,

            initContent: function initContent(/* Integer */ startIndexInContainer) {
                if(startIndexInContainer !== undefined) {
                    this.startIndexInContainer = startIndexInContainer;
                }
                this.isDownloaded = (this.base !== null);
                this.isDownloading = false;

                if(this.base) {
                    this._super(this.startIndexInContainer);
                    this.notifyListeners();
                }
            },

            addCPListener: function addCPListener(cp) {
                if(!this.listeners) {
                    this.listeners = [];
                }

                this.listeners.push(cp);
            },

            notifyListeners: function notifyListeners() {
                var i, cps = this.listeners,
                    count = (cps && cps.length) || 0;

                for(i = 0; i < count; i++) {
                    if(cps[i] && cps[i].onDemandDataReady) {
                        cps[i].onDemandDataReady(this);
                    }
                }
            },

            getAvailableRowsCount: function getAvailableRowsCount() {
                return this.isDownloaded ? this.rc : 0;
            },

            download:function() {
                if(!this.isDownloaded && !this.isDownloading) {
                    this.isDownloading = true;
                    this.dataSource.download(this.blockNum);
                }
            },

            invalid: function() {
                if(this._super) {
                    this._super();
                }
                this.isDownloaded = false;
                this.isDownloading = false;
            },

            isDataAvailable:function isDataAvailable(/* Integer */ startRow, /* Integer */ endRow) {
                return this.isDownloaded;
            }
        }
    );
})();


(function(){

    /**
     * Bitwise enumerations for Content Provider Types.
     * @private
     * @ignore
     */
    var TITLE = 1,
        COL_HEADERS = 2,
        ROW_HEADERS = 4,
        VALUES = 8,        
        STACK_TOP = 1,
        STACK_MIDDLE = 2,
        STACK_BOTTOM = 3,
        NO_STACK = 4,
        FULL_STACK = 5,
        GROUPING_SECTION = 6,
        TITLE_ROW = 7,
        RHMAP = {
            1: 30, //stack top
            2: 25, //stack middle
            3: 20, //stack bottom
            4: 70, //no stack
            5: 40, //full stack
            6: 34, //grouping section
            7: 40 //title row
        },        
        BASEFORM_PICTURE = 4,
        SUBTOTAL = 1,
        CSS = {
            TITLE: 'ig-title',
            GROUPING: 'iggroup',
            BANDING: 'igbanding',
            RIGHT_ALIGN: 'rtAlign',
            LEFT_ALIGN: 'leftAlign',
            TOTAL_ROW: 'total'
        },
        $H = mstrmojo.hash,
        $A = mstrmojo.array;
    
    /**
     * This method checks if the containing CPs require grouping sections.
     * The grouping sections are only required for the Row Headers, if there are
     * two attribute forms on it.
     *
     * @param (Object) cps The collection of aggregated content providers in this HACP.
     * @param (Object) gd The grid json data object.
     *
     */
    function hasGroupingEnabled(cps, gd) {
        var cp = cps[0],
            gts = gd.gts,
            gridTitleCount = gts.cws.length;

        return (gd.vp.gr === '1' && (gridTitleCount > 1));

    }

    /**
     * This method updates the CSS class of the grid cell with any other special css to provide
     * for the Interactive Grid specific styling.
     *
     * @param (Object) cell The model representation of the Xtab cell
     * @param (Object) info An info object that allows the function to determine which css classes to append to the cell.
     * 
     * @param (Integer) info.type       The type of the Content Provider that the cell belongs to.
     * @param (Object)  info.col        The column in the IG's visualization properties that the cell belongs to.
     * @param (Array)   info.extraCss   Additional CSS Classes to be added to the cell. 
     */
    function updateCellCSS(cell, info) {
        var applyCSS = function(cell, css) {
            if (css && cell.css && cell.css.indexOf(css) < 0) {
                cell.css += ' ' + css;
            }
        };

        //Make the column length account for a grouping column.
        var type = info.type,
            col = info.col,
            colCount = (col && col.cl) || 0,
            isTitle = (type === COL_HEADERS || type === TITLE);

        //Force alignment based on the type of cell it is. 
        if (type === COL_HEADERS || type === VALUES) {
            applyCSS(cell, CSS.RIGHT_ALIGN);
        } else if (type === TITLE || type === ROW_HEADERS) {
            applyCSS(cell, CSS.LEFT_ALIGN);
        }
        
        //Are we updating the css for the title rows?
        if (isTitle) {
            
            // Does the column have toggle enabled and are there multiple columns for the user to toggle?
            if (col && col.tg && colCount > 1) {
                
                // Have we already updated the toggle headers.
                if (!cell._v) {
                    
                    //Cache the cell value to another variable.
                    cell._v = cell.v;
                    
                    // Add an encasing span so as to place the metric toggle button close to the Header value.
                    cell.v = "<span class='toggleHeader'>" + cell.v + "</span>";
                }
            }
            
            //The col header zone or the title zome make up the title bar for interactive grids. We want to display different colors for them.
            applyCSS(cell, CSS.TITLE);
        }
        
        //Append any additional css class names that the cell may require. If null, the function will ignore it.
        $A.forEach(info.extraCss, function(css) {
            applyCSS(cell, css);
        });
    }

    function findAttributeCPIndex(cg) {
        return 0;
    }

    /**
     * Find out how many cells are stacked in one row by checking the visualization property
     * @param {Object} cols cols property in the visualization property
     * @returns v Row stack level in Integer
     */
    function getStackLevel(cols) {
        var i, cg = cols.cg, len = cg && cg.cgc, v = 1;
        for(i = 0; i < len; i++) {
            //loop through the cgs, and found the max cl
            if(cg && cg[i] && !cg[i].tg && cg[i].cl > v) {
                v = cg[i].cl;
            }
        }
        return v;
    }
    /**
     * Returns the stack position (top, middle, of bottom) of a give row.
     * @param {Integer} index The current row index
     * @param {Integer} stackLevel The stack level of Interactive Grid
     * @returns {Integer} STACK_TOP, STACK_MIDDLE, STACK_BOTTOM, or NO_STACK
     */
    function getStackPos(index, stackLevel) {
        //set default to be no stack. when stack level is less than 1, we will return NO_STACK
        var pos = NO_STACK;
        if(stackLevel > 1) {
            if(index === 0) {
                pos = STACK_TOP;
            } else if (index === stackLevel - 1) {
                pos = STACK_BOTTOM;
            } else {
                pos = STACK_MIDDLE;
            }
        }
        return pos;
    }

    /**
     * The function go through colStacks array, and find the cells that are on the same row. For example, the colStacks array
     * can have array: [ [A, B, C], [D, E], [F] ]. If the stackLevel is three, the function will
     * return [A, D, F] as the first row, [B, E, F'] as the second row, and [C, E', F'] as the third row.
     * The E' and F' means that it is an copy of E or F but with no value text.
     * @param {Array} colStacks The colStacks array that stores the stacked row cells array.
     * @param {Integer} index Current row index in the stack.
     * @param {Integer} stackLevel The stack level.
     * @returns {Array} An array of cell for a given row
     */
    function getStackedRow(/*Array*/colStacks, /*Integer*/index, /*Integer*/stackLevel) {
        var a = [], c, i, len, size;

        for(i = 0, len = colStacks.length; i < len; i++) {
            //if only one row in the stack, we need to handle a special case when there is a picture element
            //the image cell need to
            if(colStacks[i].length === 1) {
                //set the cell to be top row item
                c = $H.copy(colStacks[i][0], {});
                //set the stack position
                c.rowType = (c.rowType !== TITLE_ROW) ? getStackPos(index, stackLevel) : TITLE_ROW;
                //if the cell is a image
                if(c.ts === BASEFORM_PICTURE) {
                    //on the stack top
                    if(stackLevel === 1) {
                        c.rowType = NO_STACK;
                    } else if(!index) {
                        //only set it to be full stack when there is one picture element in the stacked cells
                        c.rowType = FULL_STACK;
                    } else {
                        //if the image is not on the stack top, we should not send the cell as image type
                        delete c.ts;
                        c.v = '';
                    }
                //if not on the stack top and not a picture element
                } else if(index) {
                    c.v = '';
                }
            } else {
                //get the cell in the colStack array
                c = colStacks[i][index];
                if(!c) {
                    //if we need to generate a empty cell to fill the stack, the cell should be a copy
                    //of the available cell on the stack bottom
                    size = colStacks[i].length;
                    c = $H.copy(colStacks[i][size-1], {});
                    c.v = '';
                }
                //set the stack position
                c.rowType = (c.rowType !== TITLE_ROW) ? getStackPos(index, stackLevel) : TITLE_ROW;
            }
            a.push(c);
        }
        return a;
    }

    /**
     * Returns the row index on the original content provider before stacking or grouping.
     * @param {Integer} ri The current row index (after grouping or stacking).
     * @returns {Integer} The row index on the original content provider.
     */
    function getOriginRowIndex(ri) {
        if(ri === 0) {
            return 0;
        }
        //check how many sections above the row
        var sc = this.sectionMap[ri - 1] || 0;
        //the current row index minus the number of sections above the row is the row count for stacked rows.
        //divide the stack levels to get correct row count
        return Math.floor((ri - sc)/this.stackLevels);
    }


    /**
     * Returns the sectionInfo for the given offset value. If the offset value is within the section header, returns the corresponding sectionInfo object.
     * @param offset The scrollTop offset from of the grid.
     * @return {Object} sectionInfo object.
     */
    function getSectionInfo(offset) {
        var i, s, si = this.sectionInfo,
            len = si.length,
            rh = this.srh,
            ls = this.lastSectionIndex;

        //find the last section info object
        s = si[ls];
        if(offset >= s.rs && offset < (s.rs + rh)) {
            return s;
        }
        //if the offset is not reached to the last section, that means we need look back of the sections to find it
        if(offset < s.rs) {
            //get the previous section
            i = ls-1;
            if(i <= 0) {
                this.lastSectionIndex = 0;
                return null;
            }

            do {
                s = si[i];
                if(offset > s.rs && offset <= (s.rs + rh)) {
                    this.lastSectionIndex = i;
                    return s;
                }
            } while(offset < s.rs && --i > 0);

            this.lastSectionIndex = i;
            return s;
        //otherwise, whether the current offset exceeds the next section boundary?
        } else {
            i = ls+1; //get the next section. Because index use zero based, the ls happens to be the next section index
            if(i >= len) {
                this.lastSectionIndex = len - 1;
                return null;
            }

            do {
                s = si[i];
                if(offset > s.rs && offset <= (s.rs + rh)) {
                    this.lastSectionIndex = i;
                    return s;
                }
            } while(offset > (s.rs + rh) && ++i < len);

            this.lastSectionIndex = i-1;
            return null;
        }
    }
    
    /**
     * Add extra column cells to the right end of the grid. The cell is used to place an arrow image '>' to indicate 
     * whether the whole row have some default action.
     * @param {Array} cells The cells for a given row.
     * @param {Integer} tgcc The toggled column count. By default the value is 1. 
     * @param {Integer} [ei] The interactive cell index.
     * @param {Integer} [rh] The row hight of the stacked/unstacked row.
     */
    function addExtraColumnCell(cells, tgcc, ei, rh) {
        var c = cells[0],
            i, len = cells.length,
            nc = {v: '', css: 'empty-igcell'},            
            rt = c && c.rowType;
        if(ei !== undefined && c && (rt === STACK_TOP || rt === NO_STACK || rt === FULL_STACK)) {
            nc = {
                v: '<div><div class="IG-ActionArrow-IMG" style="height:' + rh + 'px;top:-' + (0.5*RHMAP[rt]) + 'px;"></div></div>', 
                css: 'IG-ActionArrow',
                _ei: ei
            };
        }
        //find all the last columns, especially those columns are toggled
        for(i = len - 1; i >= len - tgcc; i--) {
            c = cells && cells[i];
            if(c) {
                c.css += ' IG-lastdatacolumn';
            }
        }
        cells.push(nc);
    }
    
    /**
     * This method converts the column widths from percentage values to pixel values based on the width available to
     * the Interactive Grid. The default value of gridWidth for content provider is 480px.
     */    
    function calculateCWS(vp, width) {
        var cols = vp.cols,
            cg = cols.cg,
            extraColumn = [{w: '0px'}];

        //Check if we need to adjust the Column widths and we haven't already done so..
        if (cols && width) {
            var cws = cols.cws,
                cwsInPx = [],
                len = cws.length,
                excludeWidth = 0,
                autoColWidth = (parseInt(vp.ar, 10) === 1) ? (width / len) : -1,
                w, cw, unsignedcol = false, excludeCol = 0,
                totalW = 0,
                i;
    
            //Check for messy data when we have no column width specified.
            for (i = 0; i < len; i++) {
                cw = cwsInPx[i] = cws[i];
                w = cw.w;
                if(w === "") {
                    unsignedcol = true;
                } else if(cw.xc) {
                    excludeWidth += parseInt(w);
                    excludeCol++;
                } else {
                    totalW += parseInt(w, 10);
                }
            }
            
            if(unsignedcol || excludeCol || totalW < 100) {
                autoColWidth = (width - excludeWidth)/(len-excludeCol);
            }

            for (i = 0; i < len; i++) {
                cw = cws[i];
                if(cw.xc) {
                    //keep the cwsInPx original value
                    continue;
                //Has the user specified fixed column widths for each of the columns?
                } else if (autoColWidth === -1) {
                    //Convert from % values to pixel values.
                    w = parseInt(cw.w, 10) * width / 100;
    
                    //If the width is undefined, then split the column widths evenly based on the column count.
                    if (!w) {
                        w = parseInt(width / cg.cgc, 10);
                    }
                } else {
                    //Auto col width case - we'll use the same column width for all columns.
                    w = (parseInt(cw.w, 10) < 0) ? 0 : autoColWidth;
                }
    
                //Change the cws property to the new pixel values.
                cwsInPx[i] = {w: w + 'px'};
            }
            
            var newCWS = [],
                cnt = 0;
            
            //Once we've calculated the column widths, we want to adjust it so that we can account for the toggleable columns.
            for (i = 0; i < len; i ++) {
                var c = cg[i],
                    //If we don't have stacking - get the column length or else initialize to 1
                    count = c.tg ? c.cl : 1, 
                    j = 0;
                
                //Check if we have a toggleable column.
                for (j = 0; j < count; j++) {
                    var wi = '0px';
                    
                    if (j === c.cc) {
                        wi = cwsInPx[i].w;
                    }
                    
                    newCWS[cnt+j] = {w: wi};
                }
                
                //Increment the count so we know 
                cnt += count;
            }
            return newCWS.concat(extraColumn);
        } else {
            return cp.cws.concat(extraColumn);
        }
    }
    
    function clearStackCols () {
        delete this.lastStackCols;
        delete this.lastAttRow;
        delete this.lastMtxRow;
    }

    /**
     * <p>XtabHACP represents a horizontal aggregation of content providers.</p>
     *
     * This is a special HACP for the Interactive Grid visualization.
     *
     *  @class
     *  @extends mstrmojo.XtabHACP
     */
    mstrmojo.InteractiveGridHACP = mstrmojo.declare(
        // superclass
        mstrmojo.XtabHACP,

        // mixins
        null,

        /**
         * @lends InteractiveGridXtabHACP
         */
        {
            scriptClass: "mstrmojo.InteractiveGridHACP",

            /**
             * This object is a map that calculates the location at which the interactive grid needs to be
             * broken down into different sections.
             */
            sectionMap: [],

            /**
             * how many cells are stacked on top of each other for a given row
             */
            stackLevels: 1,

            gridWidth: 480,
            
            lastSectionIndex: 0,

            adjustCPMaps: function adjustCPMaps() {
                var cps = this.cps,
                    attCP = this.cps[0],
                    rc = Math.max(cps[0].rc, cps[1].rc);

                //Creates the sectionMap and row height map only if we are not deal with titles and column headers
                if(attCP.type !== TITLE) {
                    var gd = this.gridData,
                        getParentElement = function(cp, n) {
                            var items = cp.base.items,
                                es = cp.lookupBase[0].es,
                                tgt = items[n].items[0],
                                cell = es && es [tgt.idx];
                            return (cell && cell.n) || ((tgt.pi && es[tgt.pi.ri || 0]) || '');
                        },
                        i, j, sc = 1, count, lastSection, curP,
                        start = 0, end = -1,
                        m, cpc, lastRow = 0,
                        shouldGroupEls = this.groupEnabled;

                    for(m = 0, i = 0, cpc = attCP.cps ? attCP.cps.length : 1; m < cpc; m++) {
                        var cp = attCP.cps ? attCP.cps[m] : attCP,
                            cprc = cp.rc;
                        //check whether the data is available
                        start = end + 1;
                        end = start + cprc - 1;
                        //set up the section info object and section map only for cp with data
                        if(cp.isDataAvailable(start, end)) {
                            //if the cp has been processed
                            if(cp.lastRow) {
                                lastRow = cp.lastRow;
                                lastSection = cp.lastSection;
                            } else {
                                i = lastRow || 0;
                                for(j = 0, sc = this.sectionMap[i-1] || 0; j < cprc; j++) {
                                    var stackLevel = this.stackLevels;

                                    curP = getParentElement(cp, j);
                                    //if it is a start of new section
                                    if(shouldGroupEls && curP !== lastSection) {
                                        lastSection = curP;
                                        this.sectionInfo.push({
                                            sn: curP, //section name
                                            rs: this.srh*sc + this.stackedRh*Math.floor((i-sc)/this.stackLevels) //row start
                                        });
                                        this.sectionMap[i] = ++sc;
                                        i++;
                                    }
                                    //if we have stacks
                                    while(stackLevel) {
                                        this.sectionMap[i] = sc;
                                        stackLevel--;
                                        i++;
                                    }
                                }
                                //if the cp has been iterated for generating the maps, set the flag so that next time we do not go through it again
                                lastRow = cp.lastRow = i;
                                //save the last section header name
                                cp.lastSection = curP;
                            }
                        } else {
                            //we should not continue is the one of the cp is missing data
                            break;
                        }
                    }
                    //Calculate the row count based on the grid structure
                    this.rc = (this.stackLevels > 1 ? rc * this.stackLevels : rc) + (shouldGroupEls ? sc : 0);
                }
            },

            onDemandDataReady: function onDemandDataReady() {
                this.adjustCPMaps();
            },

            initContent: function initContent(/* Integer */ startIndexInContainer) {
                var cps = this.cps,
                    gd = this.gridData,
                    vp = gd.vp,
                    daf = vp.daf && vp.daf.split(":"),
                    cols = vp.cols,
                    cg = cols.cg,
                    cws = cols.cws,
                    attCP = cps[findAttributeCPIndex(cg)],
                    attLB = gd.gts.row,
                    gts = gd.gts,
                    grouping = hasGroupingEnabled(cps, gd),
                    notTitleCP = attCP.type !== TITLE,
                    i, len, _c, vcps, cf, cp, igcp;
                
                //if not title cp, we need to modify the vp properties and grid title display properties before calling the super
                if(notTitleCP) {
                    if (vp.dafIdx === undefined && daf) {
                        //Figure out the index of the default action form on the actual grid data. Loop through all the attributes and find our
                        //attribute that has the default action form.
                        for (i = 0; i < attLB.length; i++) {
                            //Compare the attribute id and it's form id to find the attribute marked as the default form.
                            if (attLB[i].id === daf[0] && attLB[i].fid === daf[1]) {
                                //Cache the default action in the vp
                                vp.dafIdx = i;
                                break;
                            }
                        }                        
                    }
                    
                    //if no toggle is defined, remove titles and col headers
                    for(i = 0; i < cg.cgc; i++) {
                        if(cg[i] && cg[i].tg) {
                            //if toggle is enabled
                            break;
                        }
                    }
                    //if all the column group does not have toggle, we should hide the titles and col headers
                    if(i === cg.cgc) {
                        gd.gts.show = false;
                        gd.ghs.chs.show = false;
                    }
                }

                this._super(startIndexInContainer);
                
                this.colWidths = calculateCWS(vp, this.gridWidth);
                
                //if it is not title cp, set up IG grouping or stacking properties
                if(notTitleCP) {
                    //Set the stack levels, the maximum number of attribute forms/metrics stack on top of each other
                    this.stackLevels = getStackLevel(cols);

                    //Initialize the row heights for section row height (srh), minimum row height (mrh), stacked row height (stackedRh), and regular row height
                    if(this.stackLevels > 1) {
                        //Sticky section header row height
                        this.srh = RHMAP[GROUPING_SECTION];
                        // regular row height, min row height
                        this.rh = RHMAP[NO_STACK];
                        // minimum row height for stacked rows
                        this.mrh = RHMAP[STACK_BOTTOM];
                        // adjusted row height
                        this.stackedRh = RHMAP[STACK_TOP] + (this.stackLevels - 2)*RHMAP[STACK_MIDDLE] + RHMAP[STACK_BOTTOM];
                    } else {
                        this.srh = RHMAP[GROUPING_SECTION];
                        this.rh = this.stackedRh = this.mrh = RHMAP[NO_STACK];
                    }
                    
                    //init row height map, and set up sectionMap
                    if(grouping || this.stackLevels > 1) {
                        //Initialize the section map
                        this.sectionMap = [];

                        //Initialize the sectionInfo map
                        this.sectionInfo = [];

                        //Set the grouping property
                        this.groupEnabled = grouping;

                        //Initilialize the sectionMap, and adjust row counts
                        this.adjustCPMaps();
                        
                        //Add listener (interactive grid cp) to the onDemandCP.
                        vcps = this.cps[0].cps;
                        if(vcps) {
                            igcp = this;
                            //loop through all the ondemand content providers.
                            for(i = 0, len = vcps.length; i < len; i++) {
                                cp = vcps[i];
                                //add interactive grid cp as the listener
                                if(cp && cp.addCPListener) {
                                    cp.addCPListener(igcp);
                                }
                            }
                        }                                                
                    }
                }
            },

            getUnmergedCells: function(ri) {
                return;
            },

            /**
             * Returns a cell with resolved name and css name for group header. The css name includes 'iggroup' for the section header.
             * The row number and column number has to be within the range of the grid data.
             * @param {Integer} r Row number
             * @param {Integer} c Column number
             * @returns {Object} An cell object with at least name and css name.
             */
            getResolvedGroupHeader: function(r, c) {
                var gd = this.gridData,
                    es = gd.gts.row[c].es,
                    cell = gd.ghs.rhs.items[r].items[c];

                if(cell) {
                    if(!cell.css) {
                        cell.css = gd.css[cell.cni].n + ' iggroup';
                        cell.n = es[cell.idx].n;
                    }
                } else {
                    return { css: ' iggroup', n: ''};
                }

                return cell;
            },

            getRowCells: function (/*Integer*/ ri) {
                var cps = this.cps,
                    cells = [],
                    gd = this.gridData,
                    vp = gd.vp,
                    cg = vp.cols.cg,
                    attCP = cps[findAttributeCPIndex(cg)],
                    enableGrouping = this.groupEnabled,
                    showBanding = vp.bn === "1",
                    stackCols = [],
                    oi = getOriginRowIndex.call(this, ri),
                    eiDfa, //default form action ei
                    eiInteractiveRow,
                    lastToggledColumn = 1,
                    onTotalRow,
                    totalCell,
                    rowCells,
                    i, j, len, c, 
                    tc;

                //Are we grouping elements for this content provider?
                if (enableGrouping && (this.sectionMap[ri] !== this.sectionMap[ri-1])) {
                        //Does this Content Provider require grouping? and..
                        //Are we on a new grouping row?
                        var cell = $H.copy(attCP.getRowCells(oi)[0], {});

                        //update the colspan
                        cell.cs = this.colWidths.length;

                        //update cell row type
                        cell.rowType = GROUPING_SECTION;

                        //Apply the grouping section CSS class on the cell.
                        updateCellCSS(cell, {
                            col: null,
                            type: attCP.type,
                            extraCss: [CSS.GROUPING]
                        });

                        return [cell];
                }

                //TQMS 507190 for the first row, always clear the caches
                if(!ri) {
                    clearStackCols.call(this);
                }
                
                //get the (cached) row cells from attribute cp and metric cp
                this.lastAttRow = this.lastAttRow || (cps[0].rc ? cps[0].getRowCells(oi) : []);
                this.lastMtxRow = this.lastMtxRow || (cps[1].rc ? cps[1].getRowCells(oi) : []);

                //if the row is a total row
                rowCells = this.lastAttRow;
                len = rowCells.length;
                if (len > 0 && rowCells[0].stt) {
                    onTotalRow = true;
                    for(i = 0; i < len; i++) {
                        c = rowCells[i];
                        if(c.stt === SUBTOTAL) {
                            totalCell = c;
                            break;
                        }
                    }
                }
                
                if(!this.lastStackCols) {
                    
                    $A.forEach([this.lastAttRow, this.lastMtxRow], function(row){
                        for (i = 0; i < row.length; i++) {
                            if (row[i]._ei !== undefined) {
                                //Get the cell with the default form action.
                                if (vp.dafIdx >= 0) {
                                    tc = attCP.getRowCells(oi)[vp.dafIdx];
                                }

                                //Give the default form action value a default empty string or if default form action is set up
                                eiDfa = (vp.dafIdx >= 0) ? (tc && tc._ei) : "";
                                
                                //Returning false causes a break;
                                return false;
                            }
                        }
                    }, this);

                    //reuseable function to add css binding and default form action
                    var addInfo = function(cell, cp) {
                        if ((cp.type === TITLE || cp.type === COL_HEADERS)) { 
                            if(colGroup.tg === false) {
                                cell.n = cell.v = "";
                            }
                            cell.rowType = TITLE_ROW;
                        }
                        
                        
                        
                        // Update the cell's css property.
                        updateCellCSS(cell, {
                            col: colGroup,
                            type: cp.type,
                            extraCss: [((cp.type === VALUES || cp.type === ROW_HEADERS) && showBanding && (oi % 2 === 1)) ? CSS.BANDING : null, onTotalRow ? CSS.TOTAL_ROW : null]
                        });
                        
                        if(cell) {
                            //TQMS:512405 set column span of IG cells to be 1
                            cell.cs = 1;
                            
                            //Ensure that set the default attribute form's action on cells that don't have an action associated with them.
                            if (cell._ei===undefined && vp.dafIdx !== undefined) {
                                cell._ei = eiDfa;
                            }
                        }

                    };

                    this.lastRowIndex = 0;
                    for (j = 0; j < cg.cgc; j++) {
                        var colGroup = cg[j],
                            mCol = colGroup['mix' + colGroup.cc],
                            isMetric = mCol !== undefined,
                            cp = cps[isMetric ? 1 : 0],
                            k, p, ci, 
                            trc = {n:'', stt: SUBTOTAL, css: 'xtab-td'};
                            arr = [];

                        //if the column contains the toggle cells
                        if(colGroup.tg) {
                            
                            for (var i = 0; i < colGroup.cl; i ++) {
                                arr = [];
                                
                                //Get the current column index. If we have an extra attribute to support grouping, adjust the column index appropriately.
                                ci = isMetric ? colGroup['mix' + i] : colGroup.attForms[i].idx;
                                
                                //Get the cell we want to display
                                var rowCells = isMetric ? this.lastMtxRow : this.lastAttRow;
                                
                                //Get make a copy of the toggleable column.
                                c = rowCells[ci];
                                
                                //If we do not find a cell, then we need a copy of it
                                if(onTotalRow) {
                                    if(!c) {
                                        c = trc;
                                    } else if(c && c.stt === SUBTOTAL) {
                                        //first copy the total cell content into trc
                                        //and then assign the copied content to c 
                                        c =$H.copy(totalCell, trc);
                                    } else {
                                        c = $H.copy(c, {});
                                    }
                                } else {
                                    c = $H.copy(c, {});
                                }
    
                                //add css, rowType, etc
                                addInfo(c, cp);
    
                                arr.push(c);
                                
                                stackCols.push(arr);
                            }
                            
                            //if the toggled column group is the last column
                            if(j+1 === cg.cgc) {
                                lastToggledColumn = colGroup.cl;
                            }

                        //otherwise, the cells should stack to each
                        } else {
                            for(k = 0, len =colGroup.cl; k < len; k++) {
                                //if metric, get the value from metric row
                                if(isMetric) {
                                    p = colGroup['mix' + k];
                                    if(p!== undefined) {
                                        c = this.lastMtxRow[p];
                                    }
                                //else get the data from attribute row by using the attForms index
                                } else {                                                                        
                                    p = colGroup.attForms[k];
                                    if(p) {
                                        c = this.lastAttRow[p.idx];
                                    }
                                    
                                    //If this is the total row, we only render the first cell
                                    if (onTotalRow && !c){
                                        c = trc;
                                    }

                                }

                                //add css, rowType, etc
                                addInfo(c, cp);

                                arr.push(c);
                            }
                            
                            stackCols.push(arr);
                        }
                    }
                    this.lastStackCols = stackCols;
                }

                cells = getStackedRow(this.lastStackCols, this.lastRowIndex++, this.stackLevels);

                if(this.lastRowIndex >= this.stackLevels) {
                    clearStackCols.call(this);
                }

                //check whether the new row cells contains interactive cells
                for(i = 0, len = cells.length; i < len; i++) {
                    if(parseInt(cells[i]._ei, 10) >= 0) {
                        eiInteractiveRow = eiDfa;
                        break;
                    }
                }
                
                //put the extra column that holding the right arrow image
                addExtraColumnCell(cells, lastToggledColumn, eiInteractiveRow, this.stackedRh);
                return cells;
            },

            /**
             * Returns the row height for specific row type
             */
            getRowHeight: function getRowHeight(type) {
                var rh = RHMAP[NO_STACK];
                return RHMAP[type] || rh;
            },

            isDataAvailable:function isDataAvailable(/* Integer */ startRow, /* Integer */ endRow) {
                if(!this.onDemandIF || !this.cps[1].cps) {
                    return true;
                } else {
                    var maxRow = this.sectionMap.length, s;
                    //if no stacking or grouping
                    if(!maxRow) {
                        return this.cps[1].isDataAvailable(startRow, endRow);
                    }
                    //else
                    if(endRow > maxRow) {
                        if(startRow < maxRow) {
                            s = getOriginRowIndex.call(this, startRow);
                            return this.cps[1].isDataAvailable(s, s + (endRow-startRow));
                        } else {
                            return false;
                        }
                    } else {
                        return this.cps[1].isDataAvailable(getOriginRowIndex.call(this, startRow), getOriginRowIndex.call(this, endRow));
                    }
                }
            },

            download: function download(/* Integer */ startIndex, /* Integer */ endIndex) {
                var si = getOriginRowIndex.call(this, startIndex),
                    ei = si + Math.ceil((endIndex - startIndex)/this.stackLevels),
                    cp = this.cps[0], i, tcp,
                    targetCPs = !cp.cps? [cp] : this.cps[0]._getCPs(si, ei);

                for(i=0;i<targetCPs.length;++i) {
                    tcp = targetCPs[i];
                    tcp.download(si, ei);
                }
            },

            /**
             * Gets the section information object for the current row.
             */
            getRowCellInfo: function (offset) {
                //get the section info object if the view is scrolled some offset
                //as the section header can take space for one row, the total offset should include the section row height
                var sectionInfo = getSectionInfo.call(this, offset + this.srh),
                    lastSection, i = this.lastSectionIndex;
                if(sectionInfo) {
                    lastSection = this.sectionInfo[i - 1]; //i-1 is the current sectionInfo index, and i-2 is the previous section
                    return {
                        rowStart: sectionInfo.rs,
                        isNextRowNewSection: true,
                        sectionName: lastSection && lastSection.sn //previous section name
                    };
                } else {
                    return {
                        isNextRowNewSection: false,
                        sectionName: this.sectionInfo[i].sn
                    };
                }
            }
        }
    );
}());